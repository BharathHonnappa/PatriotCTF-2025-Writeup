Cipher from Hell — Writeup
Challenge: We are given an encryptor.py script and an encrypted file. The script encodes the flag using a custom base-3 to base-9 transformation with a fixed mapping table. Our goal is to reverse the process and recover the flag.

Encryption Process Analysis
The encryption works as follows:

Read the input flag and convert it to a big integer s (from raw bytes).

Define a 3×3 mapping matrix o:

text
(6, 0, 7)
(8, 2, 1)
(5, 4, 3)
Compute c = floor(log3(s)) — the highest power of 3 in s.

If c is even, exit with an error (flag length in base-3 must be odd? Actually, number of base-3 digits = c+1, so c odd means even number of base-3 digits).

Loop while c > -1:

Multiply ss (output integer) by 9 (building it in base 9).

Take the current two base-3 digits:

First digit: a = s // 3**c

Second digit: b = s % 3

Use o[a][b] to get a base-9 digit (0–8) and add to ss.

Remove these two digits from s:
s = (s - a*3**c) // 3

Decrease c by 2.

Write ss to encrypted as bytes.

So effectively, the base-3 representation of s is processed two digits at a time, each pair (a,b) mapped via o to a base-9 digit, forming the final integer ss.

Decryption Strategy
To decrypt:

Read encrypted → integer ss.

Convert ss to base-9 digits (most significant first).

For each base-9 digit, apply the inverse mapping to get (a,b).

Concatenate all (a,b) pairs to form the base-3 digits of the original s.

Convert base-3 digits to integer s.

Convert s to bytes → flag.

Inverse Mapping
From o:

(0,0) → 6

(0,1) → 0

(0,2) → 7

(1,0) → 8

(1,1) → 2

(1,2) → 1

(2,0) → 5

(2,1) → 4

(2,2) → 3

Inverse mapping:

text
0 → (0,1)
1 → (1,2)
2 → (1,1)
3 → (2,2)
4 → (2,1)
5 → (2,0)
6 → (0,0)
7 → (0,2)
8 → (1,0)
Decryption Code
python
import math

with open("encrypted", "rb") as f:
    enc_bytes = f.read()

ss = int.from_bytes(enc_bytes)

inv_map = {
    0: (0, 1),
    1: (1, 2),
    2: (1, 1),
    3: (2, 2),
    4: (2, 1),
    5: (2, 0),
    6: (0, 0),
    7: (0, 2),
    8: (1, 0)
}

def to_base9(n):
    if n == 0:
        return [0]
    digits = []
    while n > 0:
        digits.append(n % 9)
        n //= 9
    return digits[::-1]

base9_digits = to_base9(ss)

base3_digits = []
for d in base9_digits:
    a, b = inv_map[d]
    base3_digits.append(a)
    base3_digits.append(b)

s = 0
for d in base3_digits:
    s = s * 3 + d

# Try different byte lengths to find the correct one
for bl in range(1, 100):
    try:
        flag_bytes = s.to_bytes(bl, byteorder='big')
        flag_text = flag_bytes.decode('ascii')
        if 'pctf{' in flag_text:
            print(flag_text)
            break
    except:
        pass
Solution
Running the decryption script yields the flag:

text
pctf{7r1t7l3_b4$3_3nc0d1n9_f7w!}
